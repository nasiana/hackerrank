"""
Two Sum
"""

# My solution

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        for i in range(len(nums)):
            val = target-nums[i]
            if val in nums_map:
                return(i, nums_map[val])
            nums_map[nums[i]] = i 

"""
Best Time to Buy and Sell Stock
"""

# My solution

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        min_price = max(prices)
        length = len(prices)
        for i in range(length):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit

"""
Maximum Subarray
"""

# My solution

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        max_sum = max_sum_prev = -math.inf
        length = len(nums)
        for i in range(length):
            max_sum = max(max_sum+nums[i], nums[i])
            max_sum_prev = max(max_sum, max_sum_prev)
        return max_sum_prev

"""
Two Sum II - Input Array Is Sorted
"""

# My solution

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        for i in range(length):
            val =  target - numbers[i]
            if val in numbers and numbers.index(val) != i:
                # adding 1 as this is 1-indexed
                if i < numbers.index(val):
                    return [i+1, numbers.index(val)+1]
                else:
                    return [numbers.index(val)+1, i+1]

# Coding my own version of solution given

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        i = 0
        j = length-1
        # all the other data structures seem to behave as 0-index so have to add 1 as the array is 1-indexed
        if numbers[i] + numbers[j] == target:
            return [i+1, j+1]
        while numbers[i] + numbers[j] != target:
            if numbers[i] + numbers[j] < target:
                i += 1
            if numbers[i] + numbers[j] > target:
                j -= 1
            if numbers[i] + numbers[j] == target:
                return [i+1, j+1]

"""
The editorial solutions makes use of the list being already sorted.

We use two indices, initially pointing to the first and the last element, respectively. Compare the sum of these two elements with target.
If the sum is equal to target, we found the exactly only solution. If it is less than target, we increase the smaller index by one. 
If it is greater than target, we decrease the larger index by one. Move the indices and repeat the comparison until the solution is found.
"""

"""
Shortest Word Distance

Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest 
distance between these two words in the list.
"""

# My solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        word_dict = []
        min_d = length+1
        for i in range(length):
            if wordsDict[i] == word1 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = False
                wd2 = True
            if wordsDict[i] == word1:
                temp_idx = len(word_dict)-1
                if wd2 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    # Once we find the minDistance to be equal to 1, we can just return because it can never go down below that.
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2:
                temp_idx = len(word_dict)-1
                if wd1 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = False
                wd2 = True
        return min_d
    
# My attempt at the given solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        min_d = i1 = length+1
        i2 = 10*length 
        for i in range(length):
            if wordsDict[i] == word1:
                i1 = i
            if wordsDict[i] == word2:
                i2 = i
            min_d = min(min_d, abs(i2-i1))
        return min_d

"""
Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.
"""

# My solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        for i in range(length):
            if nums[i] == 0:
                nums.remove(nums[i])
                nums.append(0)

# Rewrote someone else's solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        cur = 0
        if len(nums) == 1:
            return nums[0]
        for c,v in enumerate(nums):
            if v != 0:
                if cur != c:
                    nums[cur], nums[c] = nums[c], 0
                cur +=1 
                    
# Someone else's solution

class Solution:
    def moveZeroes(self, nums: list) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0 and nums[slow] == 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]

            # wait while we find a non-zero element to
            # swap with you
            if nums[slow] != 0:
                slow += 1

"""
First Unique Character in a String

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
"""

# My solution

class Solution:
    def firstUniqChar(self, s: str) -> int:
        hashdict = {}
        for i in s:
            if i in hashdict:
                hashdict[i] +=1
            else:
                hashdict[i] = 1
        val_list = list(hashdict.values())
        if 1 in val_list:
            position = val_list.index(1)
            key_list = list(hashdict.keys())
            return s.index(key_list[position])
        else:
            return -1

# Editorial solution

class Solution:
    def firstUniqChar(self, s: str) -> int:
        """
        :type s: str
        :rtype: int
        """
        # build hash map : character and how often it appears
        count = collections.Counter(s)
        
        # find the index
        for idx, ch in enumerate(s):
            if count[ch] == 1:
                return idx     
        return -1

"""
Notes:
For my solution, I was able to not have to loop twice as I entered values in the dictionary through a for loop rather than using 
the collections Counter container. Therefore, the order of my Python dictionary will match that of the order of the string, and the 
first occurence will be synonymous with the first occurence in a string.

(In Python 3 onwards, Python dictionaries remember order in which values were added)

However, this isnt the same for the Collections counter container so you have to loop twice.
"""

"""
Robot Return to Origin

There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up 
at (0, 0) after it completes its moves.

You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' 
(right), 'L' (left), 'U' (up), and 'D' (down).

Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.

Note: The way that the robot is "facing" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it 
move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.
"""

# I wrote 3 solutions

# Solution 1 

class Solution:
    def judgeCircle(self, moves: str) -> bool:
        up_down = 0
        right_left = 0
        for i in moves:
            if i == 'U':
                up_down +=1
            if i == 'D':
                up_down -= 1
            if i == 'R':
                right_left +=1
            if i == 'L':
                right_left -=1
        if up_down == 0 and right_left == 0:
            return True
        else:
            return False

# Solution 2 - I used a new method I learnt from the collections module

class Solution:
    def judgeCircle(self, moves: str) -> bool:
        # remember to put the iterable in the parentheses i.e. s -> string thus collections.Counter(s)
        count = collections.Counter(moves)
        if count['U'] == count['D'] and count['L'] == count['R']:
            return True
        else:
            return False
            
# Solution 3 - this solution appeared to perform the best (best time complexity) when I ran it on Leetcode 

        
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        hashdict = {}
        hashdict['U'] = hashdict['D'] = hashdict['L'] = hashdict['R'] =  0
        for i in moves:
            hashdict[i] += 1
        if hashdict['U'] == hashdict['D'] and hashdict['L'] == hashdict['R']:
            return True
        else:
            return False
