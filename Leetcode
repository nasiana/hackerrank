"""
Two Sum
"""

# My solution

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        for i in range(len(nums)):
            val = target-nums[i]
            if val in nums_map:
                return(i, nums_map[val])
            nums_map[nums[i]] = i 

"""
Best Time to Buy and Sell Stock
"""

# My solution

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        min_price = max(prices)
        length = len(prices)
        for i in range(length):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit

"""
Maximum Subarray
"""

# My solution

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        max_sum = max_sum_prev = -math.inf
        length = len(nums)
        for i in range(length):
            max_sum = max(max_sum+nums[i], nums[i])
            max_sum_prev = max(max_sum, max_sum_prev)
        return max_sum_prev

"""
Two Sum II - Input Array Is Sorted
"""

# My solution

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        for i in range(length):
            val =  target - numbers[i]
            if val in numbers and numbers.index(val) != i:
                # adding 1 as this is 1-indexed
                if i < numbers.index(val):
                    return [i+1, numbers.index(val)+1]
                else:
                    return [numbers.index(val)+1, i+1]

# Coding my own version of solution given

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        i = 0
        j = length-1
        # all the other data structures seem to behave as 0-index so have to add 1 as the array is 1-indexed
        if numbers[i] + numbers[j] == target:
            return [i+1, j+1]
        while numbers[i] + numbers[j] != target:
            if numbers[i] + numbers[j] < target:
                i += 1
            if numbers[i] + numbers[j] > target:
                j -= 1
            if numbers[i] + numbers[j] == target:
                return [i+1, j+1]

"""
The editorial solutions makes use of the list being already sorted.

We use two indices, initially pointing to the first and the last element, respectively. Compare the sum of these two elements with target.
If the sum is equal to target, we found the exactly only solution. If it is less than target, we increase the smaller index by one. 
If it is greater than target, we decrease the larger index by one. Move the indices and repeat the comparison until the solution is found.
"""

"""
Shortest Word Distance

Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest 
distance between these two words in the list.
"""

# My solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        word_dict = []
        min_d = length+1
        for i in range(length):
            if wordsDict[i] == word1 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = False
                wd2 = True
            if wordsDict[i] == word1:
                temp_idx = len(word_dict)-1
                if wd2 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    # Once we find the minDistance to be equal to 1, we can just return because it can never go down below that.
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2:
                temp_idx = len(word_dict)-1
                if wd1 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = False
                wd2 = True
        return min_d
    
# My attempt at the given solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        min_d = i1 = length+1
        i2 = 10*length 
        for i in range(length):
            if wordsDict[i] == word1:
                i1 = i
            if wordsDict[i] == word2:
                i2 = i
            min_d = min(min_d, abs(i2-i1))
        return min_d

"""
Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.
"""

# My solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        for i in range(length):
            if nums[i] == 0:
                nums.remove(nums[i])
                nums.append(0)

# Rewrote someone else's solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        cur = 0
        if len(nums) == 1:
            return nums[0]
        for c,v in enumerate(nums):
            if v != 0:
                if cur != c:
                    nums[cur], nums[c] = nums[c], 0
                cur +=1 
                    
# Someone else's solution

class Solution:
    def moveZeroes(self, nums: list) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0 and nums[slow] == 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]

            # wait while we find a non-zero element to
            # swap with you
            if nums[slow] != 0:
                slow += 1

"""
First Unique Character in a String

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
"""

# My solution

class Solution:
    def firstUniqChar(self, s: str) -> int:
        hashdict = {}
        for i in s:
            if i in hashdict:
                hashdict[i] +=1
            else:
                hashdict[i] = 1
        val_list = list(hashdict.values())
        if 1 in val_list:
            position = val_list.index(1)
            key_list = list(hashdict.keys())
            return s.index(key_list[position])
        else:
            return -1

# Editorial solution

class Solution:
    def firstUniqChar(self, s: str) -> int:
        """
        :type s: str
        :rtype: int
        """
        # build hash map : character and how often it appears
        count = collections.Counter(s)
        
        # find the index
        for idx, ch in enumerate(s):
            if count[ch] == 1:
                return idx     
        return -1

"""
Notes:
For my solution, I was able to not have to loop twice as I entered values in the dictionary through a for loop rather than using 
the collections Counter container. Therefore, the order of my Python dictionary will match that of the order of the string, and the 
first occurence will be synonymous with the first occurence in a string.

(In Python 3 onwards, Python dictionaries remember order in which values were added)

However, this isnt the same for the Collections counter container so you have to loop twice.
"""

"""
Robot Return to Origin

There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up 
at (0, 0) after it completes its moves.

You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' 
(right), 'L' (left), 'U' (up), and 'D' (down).

Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.

Note: The way that the robot is "facing" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it 
move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.
"""

# I wrote 3 solutions

# Solution 1 

class Solution:
    def judgeCircle(self, moves: str) -> bool:
        up_down = 0
        right_left = 0
        for i in moves:
            if i == 'U':
                up_down +=1
            if i == 'D':
                up_down -= 1
            if i == 'R':
                right_left +=1
            if i == 'L':
                right_left -=1
        if up_down == 0 and right_left == 0:
            return True
        else:
            return False

# Solution 2 - I used a new method I learnt from the collections module

class Solution:
    def judgeCircle(self, moves: str) -> bool:
        # remember to put the iterable in the parentheses i.e. s -> string thus collections.Counter(s)
        count = collections.Counter(moves)
        if count['U'] == count['D'] and count['L'] == count['R']:
            return True
        else:
            return False
            
# Solution 3

        
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        hashdict = {}
        hashdict['U'] = hashdict['D'] = hashdict['L'] = hashdict['R'] =  0
        for i in moves:
            hashdict[i] += 1
        if hashdict['U'] == hashdict['D'] and hashdict['L'] == hashdict['R']:
            return True
        else:
            return False

# Editorial solution

class Solution(object):
    def judgeCircle(self, moves):
        x = y = 0
        for move in moves:
            if move == 'U': y -= 1
            elif move == 'D': y += 1
            elif move == 'L': x -= 1
            elif move == 'R': x += 1

        return x == y == 0

"""
Find Pivot Index

Given an array of integers nums, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers 
strictly to the index's right.

If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to 
the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1.
"""

# My solution

class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        length = len(nums)
        if length == 1:
            return 0
        sum_left = sum_right = 0
        for c,v in enumerate(nums):
            if c == 0:
                sum_right = sum(nums[1:])
                if sum_right == sum_left:
                    return c
                sum_left += v 
            elif c > 0:
                sum_right -= v
                if sum_left == sum_right:
                    return c
                sum_left += v
        return -1

# Editorial solution

class Solution(object):
    def pivotIndex(self, nums):
        S = sum(nums)
        leftsum = 0
        for i, x in enumerate(nums):
            if leftsum == (S - leftsum - x):
                return i
            leftsum += x
        return -1
        
"""
Notes from Leetcode on solution:

Approach #1: Prefix Sum [Accepted]
Intuition and Algorithm

We need to quickly compute the sum of values to the left and the right of every index.

Let's say we knew S as the sum of the numbers, and we are at index i. If we knew the sum of numbers leftsum that are to the left of 
index i, then the other sum to the right of the index would just be S - nums[i] - leftsum.

As such, we only need to know about leftsum to check whether an index is a pivot index in constant time. Let's do that: as we iterate
through candidate indexes i, we will maintain the correct value of leftsum.
"""

"""
Pascal's Triangle

Given an integer numRows, return the first numRows of Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
""

# My solution

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        arr= []
        for i in range(numRows):
            if i == 0:
                arr.append([1])
            elif i == 1:
                arr.append([1,1])
            else:
                sub_arr = [None]*(i+1)
                for j in range(i+1):
                    if j == 0 or j == i:
                        sub_arr[j] = 1
                    if j == 1 or j == (i-1):
                        sub_arr[j] = i
                    if j != 0 and j!= i and j!= 1 and j!=(i-1):
                        sub_arr[j] = arr[i-1][j-1] + arr[i-1][j]
                arr.append(sub_arr)
        return arr 
            
# Editorial solution

class Solution:
    def generate(self, num_rows: int) -> List[List[int]]:
        triangle = []

        for row_num in range(num_rows):
            # The first and last row elements are always 1.
            row = [None for _ in range(row_num + 1)]
            row[0], row[-1] = 1, 1

            # Each triangle element is equal to the sum of the elements
            # above-and-to-the-left and above-and-to-the-right.
            for j in range(1, len(row) - 1):
                row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]

            triangle.append(row)

        return triangle
            
"""
Notes from Leetcode editorial solution

Approach 1: Dynamic Programming
Intuition

If we have the a row of Pascal's triangle, we can easily compute the next row by each pair of adjacent values.

Algorithm

Although the algorithm is very simple, the iterative approach to constructing Pascal's triangle can be classified as dynamic programming 
because we construct each row based on the previous row.

First, we generate the overall triangle list, which will store each row as a sublist. Then, we check for the special case of 00, as we 
would otherwise return [1][1]. Since numRowsnumRows is always greater than 00, we can initialize triangle with [1][1] as its first row, 
and proceed to fill the rows as follows::

"""

"""
Pascal's Triangle II

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

Input: rowIndex = 3
Output: [1,3,3,1]
"""

# My solution

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0:
            return [1]
        if rowIndex ==1:
            return [1,1]
        prev_row = self.getRow(rowIndex-1)
        arr = [1 for _ in range(rowIndex+1)]
        for i in range(1,rowIndex):
            arr[i] = prev_row[i-1]+prev_row[i]
        return arr
