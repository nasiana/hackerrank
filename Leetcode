"""
Two Sum
"""

# My solution

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        for i in range(len(nums)):
            val = target-nums[i]
            if val in nums_map:
                return(i, nums_map[val])
            nums_map[nums[i]] = i 

"""
Best Time to Buy and Sell Stock
"""

# My solution

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        min_price = max(prices)
        length = len(prices)
        for i in range(length):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit

"""
Maximum Subarray
"""

# My solution

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        max_sum = max_sum_prev = -math.inf
        length = len(nums)
        for i in range(length):
            max_sum = max(max_sum+nums[i], nums[i])
            max_sum_prev = max(max_sum, max_sum_prev)
        return max_sum_prev

"""
Two Sum II - Input Array Is Sorted
"""

# My solution

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        for i in range(length):
            val =  target - numbers[i]
            if val in numbers and numbers.index(val) != i:
                # adding 1 as this is 1-indexed
                if i < numbers.index(val):
                    return [i+1, numbers.index(val)+1]
                else:
                    return [numbers.index(val)+1, i+1]

# Coding my own version of solution given

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        length = len(numbers)
        i = 0
        j = length-1
        # all the other data structures seem to behave as 0-index so have to add 1 as the array is 1-indexed
        if numbers[i] + numbers[j] == target:
            return [i+1, j+1]
        while numbers[i] + numbers[j] != target:
            if numbers[i] + numbers[j] < target:
                i += 1
            if numbers[i] + numbers[j] > target:
                j -= 1
            if numbers[i] + numbers[j] == target:
                return [i+1, j+1]

"""
The editorial solutions makes use of the list being already sorted.

We use two indices, initially pointing to the first and the last element, respectively. Compare the sum of these two elements with target.
If the sum is equal to target, we found the exactly only solution. If it is less than target, we increase the smaller index by one. 
If it is greater than target, we decrease the larger index by one. Move the indices and repeat the comparison until the solution is found.
"""

"""
Shortest Word Distance

Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest 
distance between these two words in the list.
"""

# My solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        word_dict = []
        min_d = length+1
        for i in range(length):
            if wordsDict[i] == word1 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2 and len(word_dict) == 0:
                word_dict.append(i)
                wd1 = False
                wd2 = True
            if wordsDict[i] == word1:
                temp_idx = len(word_dict)-1
                if wd2 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    # Once we find the minDistance to be equal to 1, we can just return because it can never go down below that.
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = True
                wd2 = False
            if wordsDict[i] == word2:
                temp_idx = len(word_dict)-1
                if wd1 == True:
                    min_d = min(min_d, i-word_dict[temp_idx])
                    if min_d == 1:
                        return min_d
                word_dict.append(i)
                wd1 = False
                wd2 = True
        return min_d
    
# My attempt at the given solution

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        length = len(wordsDict)
        min_d = i1 = length+1
        i2 = 10*length 
        for i in range(length):
            if wordsDict[i] == word1:
                i1 = i
            if wordsDict[i] == word2:
                i2 = i
            min_d = min(min_d, abs(i2-i1))
        return min_d

"""
Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.
"""

# My solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        for i in range(length):
            if nums[i] == 0:
                nums.remove(nums[i])
                nums.append(0)

# Rewrote someone else's solution

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        count = 0 
        if length > 1:
            for i in range(length):
                if nums[i] != 0:
                    nums[count], nums[i] = nums[i], nums[count]
                    count +=1
