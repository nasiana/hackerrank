"""
Sparse Arrays
"""

# My solution
def matchingStrings(strings, queries):
    n = len(strings)
    1 <= n <= 1000
    q = len(queries)
    1 <= q <= 1000
    results = []
    for i in queries:
        if type(i) == int or type(i) == float:
            abs(i) <= 20
        count = 0
        for j in strings:
            if type(j) == int or type(j) == float:
                1 <= abs(j)
            if i == j:
                count += 1
        results.append(count)
    return results 
    
 # Editorial solution
 
 """
 For this solution: as the strings come in, create a hash map to accumulate the number of occurrences of each string. A lookup is all that is needed to retrieve 
 your answers.
 """
 
 def matchingStrings(strings, queries):
    words = dict()
    ans = []
    for w in strings:
        if w in words:
            words[w] += 1
        else:
            words[w] = 1
    for q in queries:
        if q in words:
            ans.append(words[q])
        else:
            ans.append(0)
    return ans
    
 """
 Notes on the editorial solution:
 https://towardsdatascience.com/faster-lookups-in-python-1d7503e9cd38:
 You have to go through the entire list to get what you want. However, a dictionary will return the value you ask for without going through all keys.
 
 Lookups are faster in dictionaries because Python implements them using hash tables.
 
 If we explain the difference by Big O concepts, dictionaries have constant time complexity, O(1) while lists have linear time complexity, O(n)
 
 However, we have a typical space-time tradeoff in dictionaries and lists. It means we can decrease the time necessary for our algorithm but we need to use more 
 space in memory.
 
 Although dictionaries are optimized a lot more in Python 3.6, they still use more memory than lists, since you need to use space for the keys and the lookup as 
 well, while lists use space only for the values.
 
 Why is looking up entries in a dictionary so much faster? It’s because of the way Python implements dictionaries using hash tables. Dictionaries are Python’s built-in mapping type and so have also been highly optimised. Sets are implemented 
 in a similar way.
 """
 
 """
 Lonely Integer
 """

# My solution - hehe I used code that I learnt in the previous example

def lonelyinteger(a):
    n = len(a)
    hash_dict = dict()
    for i in a:
        if i in hash_dict:
            hash_dict[i] += 1
        else:
            hash_dict[i] = 1
    # the following line will find the key corresponding to value 1
    return list(hash_dict.keys())[list(hash_dict.values()).index(1)]
    
    """
    Notes: 
    The index() method returns index of corresponding value in a list.
    
    The approach used here is to find two separate lists of keys and values.
    
    Then fetch the key using the position of the value in the val_list.
    
    As key at any position N in key_list will have corresponding value at position N in val_list. 
    
    I was inspired by this code from https://www.geeksforgeeks.org/python-get-key-from-value-in-dictionary/:
# creating a new dictionary
my_dict ={"java":100, "python":112, "c":11}
 
# list out keys and values separately
key_list = list(my_dict.keys())
val_list = list(my_dict.values())
 
# print key with val 100
position = val_list.index(100)
print(key_list[position])
 
# print key with val 112
position = val_list.index(112)
print(key_list[position])
 
# one-liner
print(list(my_dict.keys())[list(my_dict.values()).index(112)])
"""

"""
Diagonal Difference
"""

# My solution 

def diagonalDifference(arr):
    n = len(arr)
    D2_idx = n - 1
    D1 = 0
    D2 = 0
    for i in range(0, n):
    # accessing elements by index in a list has a constant time complexity, it's quick and efficient
        D1 += arr[i][i]
        D2 += arr[i][D2_idx]
        D2_idx -= 1
    return abs(D1-D2)
    
 """
 Notes:
 Python doesn't have a built-in type for matrices. However, we can treat a list of a list as a matrix, therefore we code matrixes in Python as nested lists.
 """
